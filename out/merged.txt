	"path/filepath"
			path := in.Text()
			if path == "" {
				path = currentFile
			if info, err := os.Stat(path); err != nil || info.IsDir() {
				currentFile = path
func runSingleFile(conf cfg.Config, path string) error {
	lines, err := ops.ReadLines(path)
	if err := ops.PrintFileInfo(path, lines); err != nil {
	if err := ops.FilterLines(lines, keyword, filepath.Join(conf.OutDir, "filtered.txt"), true); err != nil {
	if err := ops.FilterLines(lines, keyword, filepath.Join(conf.OutDir, "filtered_not.txt"), false); err != nil {
	_ = ops.WriteLines(lines[:min(n, len(lines))], filepath.Join(conf.OutDir, "head.txt"))
	_ = ops.WriteLines(lines[max(0, len(lines)-n):], filepath.Join(conf.OutDir, "tail.txt"))
	reportPath := filepath.Join(conf.OutDir, "report.txt")
	indexPath := filepath.Join(conf.OutDir, "index.txt")
	mergedPath := filepath.Join(conf.OutDir, "merged.txt")
	return ops.ProcessBatch(files, reportPath, indexPath, mergedPath)
package main

import (
	"bufio"
	"fmt"
	"log"
	"os"

	"fileops/internal/cfg"
	"fileops/internal/ops"
)

func main() {
	// 1) Charger la config
	conf, err := cfg.Load("config.txt")
	if err != nil {
		log.Fatalf("Config: %v\n", err)
	}

	currentFile := conf.DefaultFile
	in := bufio.NewScanner(os.Stdin)

	for {
		fmt.Printf(`
============= MENU ===============
[f] Changer de fichier courant (actuel: %s)
[a] Analyse fichier courant
[b] Analyse répertoire
[q] Quitter
> `, currentFile)

		if !in.Scan() {
			fmt.Println("\nBye.")
			return
		}
		choice := in.Text()

		switch choice {
		case "f":
			fmt.Print("Chemin du fichier : ")
			if !in.Scan() {
				continue
			}
			}
				fmt.Println("Fichier invalide")
			} else {
			}

		case "a":
			if err := runSingleFile(conf, currentFile); err != nil {
				fmt.Printf("Erreur: %v\n", err)
			}

		case "b":
			fmt.Print("Répertoire : ")
			if !in.Scan() {
				continue
			}
			dir := in.Text()
			if dir == "" {
				dir = conf.BaseDir
			}
			if err := runBatch(conf, dir); err != nil {
				fmt.Printf("Erreur: %v\n", err)
			}

		case "q":
			fmt.Println("À la prochaine")
			return
		default:
			fmt.Println("Choix inconnu.")
		}
	}
}

	if err != nil {
		return err
	}

		return err
	}

	scanner := bufio.NewScanner(os.Stdin)
	fmt.Print("Mot-clé pour filtrer : ")
	if !scanner.Scan() {
		return nil
	}
	keyword := scanner.Text()

		return err
	}
		return err
	}

	fmt.Print("Combien de lignes pour head/tail ? ")
	if !scanner.Scan() {
		return nil
	}
	var n int
	fmt.Sscan(scanner.Text(), &n)


	return nil
}

func runBatch(conf cfg.Config, dir string) error {
	files, err := ops.ListTxt(dir)
	if err != nil {
		return err
	}

}

func min(a, b int) int {
	if a < b {
		return a
	}
	return b
}

func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}
package main

import (
	"bufio"
	"fmt"
	if a > b {
		return a
	}
	return b
}
blablablabla blablablablablablablablablablabla
voila voila
alors alors
demain
je dois finir le niveau 12
blablablabla blablablablablablablablablablabla blablablabla bla bla bla
